const {Neo4jGraphQL} = require("@neo4j/graphql");
const {OGM} = require("@neo4j/graphql-ogm");
const {ApolloServer} = require("apollo-server");
const neo4j = require("neo4j-driver");
const fs = require("fs");
const dotenv = require("dotenv");
const path = require("path");
const nJwt = require("njwt");
const bcrypt = require("bcrypt");

// Load contents of .env as environment variables
dotenv.config();

// Load GraphQL type definitions from schema.graphql file
const typeDefs = fs
    .readFileSync(path.join(__dirname, "todo.graphql"))
    .toString("utf-8");

// Create Neo4j driver instance
const driver = neo4j.driver(
    process.env.NEO4J_URI,
    neo4j.auth.basic(process.env.NEO4J_USER, process.env.NEO4J_PASSWORD)
);

const ogm = new OGM({typeDefs, driver});
const User = ogm.model("User");

// The mutation to sign up a new user
const signUp = async (_source, {username, password}) => {

    // Check if the username is already used
    const [existingUser] = await User.find(
        {
            where: {
                username,
            },
        },
    );

    if (existingUser) {
        throw new Error("Username already used");
    }

    // Check password complexity
    if (password.length < 8) {
        throw new Error("Password must be at least 8 characters long");
    }

    if (!/[A-Z]/.test(password)) {
        throw new Error("Password must contain at least one uppercase letter");
    }

    if (!/[a-z]/.test(password)) {
        throw new Error("Password must contain at least one lowercase letter");
    }

    if (!/[0-9]/.test(password)) {
        throw new Error("Password must contain at least one number");
    }

    // Hash the password for security
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create the user
    const roles = ["User"];
    const user = await User.create(
        {
            input:
                [
                    {
                        username,
                        password: hashedPassword,
                        roles,
                    }
                ]
        }
    );

    // Return the token
    return nJwt.create({sub: user.id, roles}, process.env.JWT_SECRET).compact();
};

// The mutation to sign in
const signIn = async (_source, {username, password}) => {

    // Check if the username exists
    const [existingUser] = await User.find(
        {
            where:
                {
                    username,
                }
        }
    );

    if (!existingUser) {
        throw new Error("Username not found");
    }

    // Check if the password is correct
    const passwordMatch = await bcrypt.compare(password, existingUser.password);

    if (!passwordMatch) {
        throw new Error("Incorrect password");
    }

    // Return the token
    return nJwt.create({sub: existingUser.id, roles: existingUser.roles}, signingKey).setExpiration().compact();
}

/////////////////////////////////////// Query ///////////////////////////////////////

// The query me
const me = async (_source, _args, context) => {
    const userId = context.jwt.sub;

    // Check if the user exists
    const [user] = await User.find(
        {
            where:
                {
                    id: userId,
                }
        }
    );

    if (!user) {
        throw new Error("User not found");
    }

    return user;
}

// The query myTaskLists
const myTaskLists = async (_source, _args, context) => {
    // Retrieve the user ID from the JWT in the context
    const userId = context.jwt.sub;

    // Retrieve the task lists that are owned by the user with the specified ID
    return await TaskList.find(
        {
            where:
                {
                    owner: {
                        id: userId,
                    }
                }
        }
    );
}


// Create The resolvers
const resolvers = {
    Mutation: {
        signUp,
        signIn,
    }
}

// Create executable GraphQL schema from GraphQL type definitions,
// using @neo4j/graphql to autogenerate resolvers
const neoSchema = new Neo4jGraphQL({
    typeDefs,
    resolvers,
    config: {
        jwt: {
            secret: "dFt8QaYykR6PauvxcyKVXKauxvQuWQTc"
        }
    }
});
const signingKey = "dFt8QaYykR6PauvxcyKVXKauxvQuWQTc";

// Create ApolloServer instance that will serve GraphQL schema created above
// Inject Neo4j driver instance into the context object, which will be passed
//  into each (autogenerated) resolver
const server = new ApolloServer({
    context: ({req}) => ({driver, req}),
    schema: neoSchema.schema,
    //introspection: true,
//  playground: false
});

// Start ApolloServer
server.listen().then(({url}) => {
    console.log(`GraphQL server ready at ${url}`);
});